key.dat 		contains a 16-byte string
hexkey.dat 		contains the Hex convertion of the key
headmess1.dat	contains head+mess1
cipher.dat		contains ciphertext of head+mess1
padded.dat		contains head+mess1+padding
headmess2.dat	contains head+mess2
forgery.dat		contains head+mess1+padding+tag1+mess2 

Orden de comandos:

$cat head.dat mess1.dat > headmess1.dat

$openssl enc -aes-128-cbc -K `cat hexkey.dat` -iv 0 -in headmess1.dat -out cipher.dat

$openssl enc -d -aes-128-cbc -K `cat hexkey.dat` -iv 0 -nopad -in cipher.dat -out padded.dat

$openssl enc -aes-128-cbc -K `cat hexkey.dat` -iv 0 -in headmess1.dat | tail -c 16 > tag1.dat

$cat head.dat mess2.dat > headmess2.dat

$openssl enc -aes-128-cbc -K `cat hexkey.dat` -iv 0 -in headmess2.dat | tail -c 16 > tag2.dat

$cat padded.dat tag1.dat mess2.dat > forgery.dat

$openssl enc -aes-128-cbc -K `cat hexkey.dat` -iv 0 -in forgery.dat | tail -c 16 > forgertag.dat


forgertag.dat == tag2.dat

Orden de comandos ataque (sin conocer la clave):

$bash get_padding.sh mess1.dat //para obtener el mensaje 1 junto al padding en padded.dat

$cat head.dat padded.dat tag1.dat mess2.dat > forgery.dat //obtener el forgery 

De nuevo forgertag.dat == tag2.dat


